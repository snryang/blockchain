## 《GO语言实践》
### 第一章 关于 Go 语言的介绍
- Go 语言内置并发机制，增加goroutine协程,channel通道概念，使并发编程变简单
- GO语言类型系统，使用组合的概念替换面象对象编程继承，抽象类的概念，接口只需要定义，确保签名一致，不需要额外声明。个人喜欢组合的概念。
- 接口要小，只定义一个单一的动作，会更有利于使用组合来代码复用，如：io.Reader
### 第二章 快速开始一个 Go 程序
- main函数执行之前会执行init函数，引入包的时，有时需要让包内的init执行，但是引入了包不调用，编译不能通过，可以在引入包前加入符号_
- 文件夹名即包名，同一个文件夹下的.go文件保持包名一致,var关键字声明包级变量，包级变量，大写则对包公开，小写则为私有，约定大于配置，节省了关键字如public private.
- 所有变量都被初始化为其零值。对于数值类型，零值是 0；对于字符串类型，零值是空字符串；对于布尔类型，零值是 false；对于指针，零值是 nil。对于引用类型来说，所引用的底层数据结构会被初始化为对应的零值。但是被声明为其零值的引用类型的变量，会返回 nil 作为其值。
- 通过sync.WaitGroup来跟踪goroutine的工作是否完成，确保main函数终止时，goroutine的工作都完成了。和nodejs中的aync模块很类似，以前需要自己去编写代码控制线程，go直接提供了基础标准库
- 所有的 goroutine 都会因为闭包共享同样的变量
- 函数返回多个值的时候，如果需要忽略其中某个值，可以使用 _ ,简洁，使用go启动一个goroutine的语法也非常简洁
- go函数可以返回多个值的设计，以及对error异常的规则约定，非常爽。另外go 没有try catch 的设计，需要手动处理每一个返回的错误，欣赏这个原则，面对一些C# java代码大量的try catch，真心觉得丑。
- 大部分方法在被调用后都需要维护接收者的值的状态，所以，一个最佳实践是，将方法的接收者声明为指针。使用指针作为接收者声明的方法，只能在接口类型的值是一个指针的时候被调用。使用值作为接收者声明的方法，在接口类型的值为值或者指针时，都可以被调用，编译器会处理。
-  range对通道有效，for range 循环会一直阻塞，直到有结果写入通道。 channel通道没有关闭时，会终止。


### 第六章 并发
- 1.5^ Go语言的运行时默认会为每个可用的物理处理器分配一个逻辑处理器
- 并发（concurrency）不是并行（parallelism）。并行是让不同的代码片段同时在不同的物理处理器上执行。并行的关键是同时做很多事情，而并发是指同时管理很多事情，这些事情可能只做了一半就被暂停去做别的事情了。在很多情况下，并发的效果比并行好，因为操作系统和硬件的总资源一般很少，但能支持系统同时做很多事情。这种“使用较少的资源做更多的事情”的哲学，也是指导 Go 语言设计的哲学。
- 当通道关闭后，goroutine 依旧可以从通道接收数据，但是不能再向通道里发送数据。能够从已经关闭的通道接收数据这一点非常重要，因为这允许通道关闭后依旧能取出其中缓冲的全部值，而不会有数据丢失。
- 

### 第七章 并发模式
- select case 针对通道会被阻塞，如果有default则流程变为非阻塞方式。

### 第八章 单元测试
``` golang
server := mockServer()
defer server.Close()
```
- defer这个代码设计非常爽，避免代码分支写很多的server.Close()语句
- 如果包使用"_test"这种方式命名,不与文件夹名称保持一致，测试代码只能访问包里公开的标识符。即便测试代码文件和被测试的代码放在同一个文件夹中，也只能访问公开的标识符。
- 基准测试函数必须以 Benchmark 开头，接受一个指向 testing.B 类型的指针作为唯一参数。


### Think
``` golang
jsonByte,err := json.Marshal(&u)
if(err != nil){		
    json.NewEncoder(rw).Encode(&u)
    fmt.Println("io.Write")
}else{
    rw.Write(jsonByte);
    fmt.Println("custom C#");
}
```
json.NewEncoder(rw).Encode(&u) 和 rw.Write(jsonByte) 作用相同，后者是常用编码思维习惯的代码，前者为go风格代码,主要体现为io.Write接口的设计和运用。

``` golang
r := strings.NewReplacer("<", "&lt;", ">", "&gt;")
fmt.Println(r.Replace("This is <b>HTML</b>!"))
```
函数式风格代码，先定义业务规则，再传入需要处理的数据

## 《Go语言标准库践》
https://books.studygolang.com/The-Golang-Standard-Library-by-Example/


